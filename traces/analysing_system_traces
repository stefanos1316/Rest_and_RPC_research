SYSTEM TRACES

gRPC
====
Go spend 95.64% of its time on futex syscall (futex is a blocking operation for waiting until a certain condition becomes valid)
Java spend 79.75% of its time on wait4 syscall, 3.25% for readlink, 3.14% for stat, and 2.62% for clone
JS spends 49.90% on clock_gettime, 23.76% on write, 13.16% on brk
Python spends 38.25% on clock_gettime, 32.86% on sendmsg, 16.23% on recvmsg, 11.02% on epoll_wait


RPC
===
Go spends  80.97% on wait4, 7.51% on futex
Java spends 100% on futex command
JS 41.54% on socket, 18.30% on epoll_ctl, 8.45% on connect, 8.39% on write, 4.93% on munmap
Python 38.85% on recvfrom, 21.09% on connect, 16.08% on socket, 13.52% on close, 10.31% on sendto


REST
====
Go 76.41% on wait4, 10.41% on futex
Java 99.95% of its time on wait4 
JS 38.21% on socket, 17.32% on epoll_ctl, 9.50% on write, 6.92% on connect, 5.84% on close, 5.13% on munmap
Python  20.52% on recvfrom, 16.89% on connect, 14.73% on close, 14.10% on stat, 11.90% on socket, 8.42% on sendto, 8.40% on fcntl


Overall observation
===================
gRPC --	Go's, overall, imlementations spend most of their time on wait4 and waitid (waiting process to change state and returns child's process resource usage information) 
	that is caused from futex (event blocking operations) system call which is not the case with JavaScript, that is ranked as the most efficient one in terms of 
	energy usage and run-time performance.

RPC ---	JavaScript RPC has the most efficient results due to the fact that opens has many socket and connect system calls that indicates many parallel transfers are being 
	performed which is not the case for Go and Java. 
	Go and Java are using the futex system calls that illustrates the waiting for an event. This can mainly be the reason why JavaScript achieves superior results 
	it terms of energy consumption and execution time.
	In contrast, JavaScript is using the epoll_ctl system call (control interface for an epoll file descriptor) 

